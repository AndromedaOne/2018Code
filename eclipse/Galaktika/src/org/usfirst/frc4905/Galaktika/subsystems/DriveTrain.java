// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4905.Galaktika.subsystems;

import org.usfirst.frc4905.Galaktika.Robot;
import org.usfirst.frc4905.Galaktika.RobotMap;
import org.usfirst.frc4905.Galaktika.Ultrasonic;
import org.usfirst.frc4905.Galaktika.commands.TeleOpDrive;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import Utilities.Tracing.Trace;
import Utilities.Tracing.TracePair;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.Timer;

import org.usfirst.frc4905.Galaktika.Ultrasonic;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import kinematics.MPSource;
import kinematics.MotionProfilingController;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveTrain extends Subsystem {
	// TODO: Find value of encoder ticks per inch by rolling the robot
	// TODO: and measuring the distance in inches and ticks.
	// TODO: The following value is simply a guess from Hardware.
	public static final double ENCODER_TICKS_PER_INCH = 1000;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final WPI_TalonSRX leftTopTalon = RobotMap.driveTrainLeftTopTalon;
	private final WPI_TalonSRX leftBottomTalon = RobotMap.driveTrainLeftBottomTalon;
	private final SpeedControllerGroup leftSpeedController = RobotMap.driveTrainLeftSpeedController;
	private final WPI_TalonSRX rightTopTalon = RobotMap.driveTrainRightTopTalon;
	private final WPI_TalonSRX rightBottomTalon = RobotMap.driveTrainRightBottomTalon;
	private final SpeedControllerGroup rightSpeedController = RobotMap.driveTrainRightSpeedController;
	private final DifferentialDrive differentialDrive = RobotMap.driveTrainDifferentialDrive;
	private final Compressor compressor = RobotMap.driveTrainCompressor;
	private final Ultrasonic frontUltrasonic = RobotMap.driveTrainFrontUltrasonic;

	private static final double kEncoderMaxVelocity = 130000.0; // Encoder ticks per second
	private static final double kEncoderMaxAcceleration = 98556.82501503047;// *500; // Encoder ticks per second^2
	private static final double kEncoderMaxJerk = 630168.7582546938;// *100000; // Encoder ticks per second^3
	private static final double kEncoderVelocityToOutputRatio = 1.0 / kEncoderMaxVelocity;

	public static double getMaxVelocity() {
		return kEncoderMaxVelocity;
	}

	public static double getMaxAcceleration() {
		return kEncoderMaxAcceleration;
	}

	public static double getMaxJerk() {
		return kEncoderMaxJerk;
	}

	private double m_encoderMPPositionkp = 10.0;
	private double m_encoderMPPositionki = 0.0;
	private double m_encoderMPPositionkd = 0.0;

	private double m_encoderMPVelocitykp = 0.0;
	private double m_encoderMPVelocityki = 0.0;
	private double m_encoderMPVelocitykd = 0.0;
	private double m_encoderMPVelocitykf = kEncoderVelocityToOutputRatio;

	private double kEncoderMPTolerance = 1000;
	private MotionProfilingController m_encoderMotionProfilingController;
	public MotionProfilingController getEncoderMPController() {
		return m_encoderMotionProfilingController;
	}


	private static final double kGyroMaxVelocity = 0.0; // degrees per second
	private static final double kGyroMaxAcceleration = 0.0; // degrees per second^2
	private static final double kGyroMaxJerk = 0.0; // degrees per second^3
	private static final double kGyroVelocityToOutputRatio = 1.0 / kEncoderMaxVelocity;

	public static double getGyroMaxVelocity() {
		return kGyroMaxVelocity;
	}

	public static double getGyroMaxAcceleration() {
		return kGyroMaxAcceleration;
	}

	public static double getGyroMaxJerk() {
		return kGyroMaxJerk;
	}

	private double m_gyroMPPositionkp = 10.0;
	private double m_gyroMPPositionki = 0.0;
	private double m_gyroMPPositionkd = 0.0;

	private double m_gyroMPVelocitykp = 0.0;
	private double m_gyroMPVelocityki = 0.0;
	private double m_gyroMPVelocitykd = 0.0;
	private double m_gyroMPVelocitykf = kGyroVelocityToOutputRatio;

	private double kgyroMPTolerance = 1000;
	private MotionProfilingController m_gyroMotionProfilingController;
	public MotionProfilingController getGyroMPController() {
		return m_gyroMotionProfilingController;
	}

	private double m_gyroPreviousPosition = Double.NaN;
	private double m_gyroPreviousTime = 0.0;

	
	private double m_ultrasonicMPPositionkp = 10.0;
	private double m_ultrasonicMPPositionki = 0.0;
	private double m_ultrasonicMPPositionkd = 0.0;
	private double m_ultrasonicMPSetpoint = 0.0;

	private double kUltrasonicMPTolerance = 1000;
	private MotionProfilingController m_ultrasonicMotionProfilingController;
	public MotionProfilingController getUltrasonicMPController() {
		return m_ultrasonicMotionProfilingController;
	}

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Encoder PID

	private double m_encoderPIDP = 0.0001;
	private double m_encoderPIDI = 0;
	private double m_encoderPIDD = 0;
	private double m_encoderPIDF = 0;
	private double m_encoderPIDOutputMax = 1;
	private double m_encoderPIDTolerance = 1000;

	// Ultrasonic PID
	private PIDController m_ultrasonicPID;
	private double m_P = .2;
	private double m_I = .00000;
	private double m_D = .0;
	private double m_maxSpeed = 1;
	private double m_f = 0;
	private double m_tolerance = 1;
	private double m_noiseTolerance = 64;
	private double m_pingDelay = 0.02;
	private int m_timesDistanceAveraged = 5;
	// Gyro Correction for move
	private static final double kProportion = .05;

	private double courseCorrectionDelay = 0;

	private double SavedAngle = 0;


	public DriveTrain() {
		leftBottomTalon.setStatusFramePeriod(StatusFrameEnhanced.Status_2_Feedback0, 1, 10);
		leftBottomTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, 10);
		frontUltrasonic.setEnabled(true);
		frontUltrasonic.setAutomaticMode(true);
		UltrasonicPIDOutputFront ultraPIDOutput = new UltrasonicPIDOutputFront();
		UltrasonicPIDin pdIn = new UltrasonicPIDin();
		m_ultrasonicPID = new PIDController(m_P, m_I, m_D, m_f, pdIn, ultraPIDOutput);
		m_ultrasonicPID.setAbsoluteTolerance(m_tolerance);
		m_ultrasonicPID.setOutputRange(-m_maxSpeed, m_maxSpeed);
		frontUltrasonic.SetUltrasonicNoiseTolerance(m_noiseTolerance);
		frontUltrasonic.SetUltrasonicPingDelay(m_pingDelay);
		frontUltrasonic.SetUltrasonicAveragedAmount(m_timesDistanceAveraged);
		LiveWindow.add(m_ultrasonicPID);
		m_ultrasonicPID.setName("Ultrasonic","Ultrasonic PID");
		initializeEncoderPID();
		initGyroPIDDeltaAngle();
		
		initializeEncoderMP();
		initializeGyroMP();
		initializeUltrasonicMP();
	}

	// Ultrasonic Code - Begins

	public double getDistanceFromFront() {
		return frontUltrasonic.getRangeInches();
	}

	private class UltrasonicPIDin implements PIDSource {

		@Override
		public void setPIDSourceType(PIDSourceType pidSource) {
		}

		@Override
		public PIDSourceType getPIDSourceType() {

			return PIDSourceType.kDisplacement;
		}

		@Override
		public double pidGet() {
			return getDistanceFromFront();
		}

	}

	public boolean doneUltrasonicFrontPID() {
		Trace.getInstance().addTrace(false, "MoveWithUltrasonic",
		Trace.getInstance().addTrace("MoveWithUltrasonic", new TracePair("Current Distance", getDistanceFromFront()),
				new TracePair("PID Error", m_ultrasonicPID.getError()),
				new TracePair("PID Output", m_ultrasonicPID.get()));
		boolean done = m_ultrasonicPID.onTarget();
		debug("bottom of doneUltrasonicFrontPID returning " + done);
		return done;
	}

	private void debug(String information) {
		System.out.println("In DriveTrain.java " + information);
		System.out.flush();
	}

	public void stopUltrasonicFrontPID() {
		m_ultrasonicPID.disable();

	}

	public void moveWithUltrasonicPID(double distanceToGoTo) {
		m_ultrasonicPID.setSetpoint(distanceToGoTo);
		m_ultrasonicPID.enable();

	}

	private class UltrasonicPIDOutputFront implements PIDOutput {

		@Override
		public void pidWrite(double output) {
		}
	}

	public void intializeUltrasonicPIDFront(double distanceToDriveTo) {
		debug("top of intializeUltrasonicPIDFront");
		moveWithUltrasonicPID(distanceToDriveTo);
		debug("bottom of intializeUltrasonicPIDFront");
	}

	// Ultrasonic Code - Ends

	@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
		setDefaultCommand(new TeleOpDrive());
	}

	@Override
	public void periodic() {
		// Put code here to be run every loop

	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	private PIDController m_encoderPID;

	private class EncoderPIDIn implements PIDSource {

		@Override
		public void setPIDSourceType(PIDSourceType pidSource) {
			// TODO Auto-generated method stub

		}

		@Override
		public PIDSourceType getPIDSourceType() {
			// TODO Auto-generated method stub
			return PIDSourceType.kDisplacement;
		}

		@Override
		public double pidGet() {
			// TODO Auto-generated method stub
			return getEncoderTicks();
		}

	}

	private class EncoderPIDOut implements PIDOutput {
		public void pidWrite(double output) {
			// Negation causes forward movement for positive values
			move(-output, 0);
		}
	}

	public void initializeEncoderPID() {
		EncoderPIDIn encoderPIDIn = new EncoderPIDIn();
		EncoderPIDOut encoderPIDOut = new EncoderPIDOut();
		m_encoderPID = new PIDController(m_encoderPIDP, m_encoderPIDI, m_encoderPIDD, m_encoderPIDF, encoderPIDIn,
				encoderPIDOut);
		m_encoderPID.setOutputRange(-m_encoderPIDOutputMax, m_encoderPIDOutputMax);
		m_encoderPID.setAbsoluteTolerance(m_encoderPIDTolerance);
		LiveWindow.add(m_encoderPID);
		m_encoderPID.setName("DriveTrain","Encoder PID");
	}

	public void enableEncoderPID(double setpoint) {
		double currentEncoderPosition = getEncoderTicks();
		m_encoderPID.setSetpoint(setpoint + currentEncoderPosition);
		m_encoderPID.enable();
	}

	public boolean isDoneEncoderPID() {
		return m_encoderPID.onTarget();
	}

	public void disableEncoderPID() {
		m_encoderPID.disable();
	}

	private PIDController m_gyroPIDSource;

	private class GyroPIDIn implements PIDSource {
		public void setPIDSourceType(PIDSourceType PIDSource) {

		}

		public PIDSourceType getPIDSourceType() {
			return PIDSourceType.kDisplacement;
		}

		public double pidGet() {
			return RobotMap.navX.getRobotAngle();
		}
	}

	private class GyroPIDOut implements PIDOutput {

		@Override
		public void pidWrite(double output) {
			move(0, output);
		}
	}

	public void initGyroPIDDeltaAngle() {
		GyroPIDIn gyroPIDIn = new GyroPIDIn();
		GyroPIDOut gyroPIDOut = new GyroPIDOut();
		double gyroPIDP = 0.1;
		double gyroPIDI = 0.0;
		double gyroPIDD = 0.0;
		double gyroPIDF = 0.0;
		double gyroPIDOutputRange = 0.5;
		double gyroPIDAbsTolerance = 1;
		m_gyroPIDSource = new PIDController(gyroPIDP, gyroPIDI, gyroPIDD, gyroPIDF, gyroPIDIn, gyroPIDOut);
		m_gyroPIDSource.setOutputRange(-gyroPIDOutputRange, gyroPIDOutputRange);
		m_gyroPIDSource.setAbsoluteTolerance(gyroPIDAbsTolerance);
		LiveWindow.add(m_gyroPIDSource);
		m_gyroPIDSource.setName("Gyro","Gyro PID");

	}

	public void enableGyroPID(double setPoint) {
		double endAngle = RobotMap.navX.getRobotAngle() + setPoint;
		m_gyroPIDSource.setSetpoint(endAngle);
		m_gyroPIDSource.enable();

	}

	public boolean gyroPIDIsDone() {
		Trace.getInstance().addTrace(false, "GyroPID",
				new TracePair("Avg Error", m_gyroPIDSource.getError()), new TracePair("Output", m_gyroPIDSource.get()));
		return m_gyroPIDSource.onTarget();
	}

	public void stopGyroPid() {
		m_gyroPIDSource.disable();
	}

	public double getEncoderTicks() {
		// TODO Auto-generated method stub
		return leftBottomTalon.getSelectedSensorPosition(0);
	}

	public void move(double forwardBackSpeed, double rotateAmount) {
		// Rotation was inverted, -rotation fixes that
		move(forwardBackSpeed, rotateAmount, true);
	}

	public void move(double forwardBackSpeed, double rotateAmount, boolean squaredInput) {
		// Rotation was inverted, -rotation fixes that
		differentialDrive.arcadeDrive(forwardBackSpeed, -rotateAmount, squaredInput);
	}

	public void stop() {
		differentialDrive.stopMotor();
	}

	public void gyroCorrectMove(double forwardBackwardStickValue, double rotateStickValue, double mod) {
		gyroCorrectMove(forwardBackwardStickValue, rotateStickValue, mod, true);
	}

	public void gyroCorrectMove(double forwardBackwardStickValue, double rotateStickValue, double mod,
			boolean squaredInput) {
		double robotAngle = RobotMap.navX.getRobotAngle();
		double correctionEquation = (SavedAngle - robotAngle) * kProportion;
		int correctionMode = -1;
		double newForwardBackwardStickValue = 0;
		double newRotateStickValue = 0;
		if (forwardBackwardStickValue == 0 && rotateStickValue == 0) {
			correctionMode = 0;
			SavedAngle = robotAngle;
			newForwardBackwardStickValue = 0;
			newRotateStickValue = 0;
		} else if (rotateStickValue != 0) {
			courseCorrectionDelay = 0;
			correctionMode = 1;
			SavedAngle = robotAngle;
			newForwardBackwardStickValue = forwardBackwardStickValue * mod;
			newRotateStickValue = rotateStickValue * mod;
		} else if (courseCorrectionDelay > 25) {
			// disable correction for half a second after releasing the turn stick, to allow
			// the driver
			// to let the machine drift naturally, and not correct back to the gyro reading
			// from
			// the instant the driver released the turn stick.
			// PROBLEM, corrects every 25 cycles because I'm dumb...

			// reassign the correctionEquation to the latest direction that we've been "free
			// driving" in
			correctionEquation = (SavedAngle - robotAngle) * kProportion;
			correctionMode = 2;
			newForwardBackwardStickValue = forwardBackwardStickValue * mod;
			newRotateStickValue = correctionEquation;

		} else {
			// should all cases fail, just drive normally
			newForwardBackwardStickValue = forwardBackwardStickValue * mod;
			newRotateStickValue = rotateStickValue * mod;
		}

		if (courseCorrectionDelay == 24) {
			// take the most recent course and make that our angle
			SavedAngle = robotAngle;
		}

		Trace.getInstance().addTrace(false, "GyroCorrection",
				new TracePair("forwardBackwardStickValue", newForwardBackwardStickValue),
				new TracePair("SavedAngle", SavedAngle), new TracePair("robotAngle", robotAngle),
				new TracePair("kProportion", kProportion), new TracePair("correctionEquation", correctionEquation),
				new TracePair("correctionMode", (double) correctionMode));

		courseCorrectionDelay++;
		Robot.driveTrain.move(newForwardBackwardStickValue, newRotateStickValue, squaredInput);
	}

	private class EncoderMPOut implements PIDOutput {

		@Override
		public void pidWrite(double output) {
			gyroCorrectMove(output, 0.0, 1.0, false);
		}

	}

	private class EncoderMPIn implements MPSource {

		@Override
		public double getPosition() {
			return getEncoderTicks();
		}

		@Override
		public double getVelocity() {
			return getTalonVelocity();
		}

	}

	public void initializeEncoderMP() {
		EncoderMPIn encoderMPIn = new EncoderMPIn();
		EncoderMPOut encoderPIDOut = new EncoderMPOut();
		m_encoderMotionProfilingController = new MotionProfilingController(m_encoderMPPositionkp, m_encoderMPPositionki,
				m_encoderMPPositionkd, m_encoderMPVelocitykp, m_encoderMPVelocityki, m_encoderMPVelocitykd,
				m_encoderMPVelocitykf, kEncoderMaxVelocity, kEncoderMaxAcceleration, kEncoderMaxJerk, encoderMPIn,
				encoderPIDOut);
		m_encoderMotionProfilingController.setAbsoluteTolerance(kEncoderMPTolerance);

	}

	public void enableEncoderMP(double setpoint) {
		m_encoderMotionProfilingController.setSetpoint(setpoint);
		m_encoderMotionProfilingController.enable();
	}

	public boolean isDoneEncoderMP() {

		return m_encoderMotionProfilingController.onTarget();
	}

	public void disableEncoderMP() {
		m_encoderMotionProfilingController.disable();
	}

	public double getTalonVelocity() {
		return leftBottomTalon.getSelectedSensorVelocity(0) * 10;
	}

	public double getEncoderPosition() {
		return leftBottomTalon.getSelectedSensorPosition(0);
	}

	private class GyroMPOut implements PIDOutput {

		@Override
		public void pidWrite(double output) {
			gyroCorrectMove(0.0, output, 1.0, false);
		}

	}

	private class GyroMPIn implements MPSource {

		@Override
		public double getPosition() {
			return getGyroPosition();
		}

		@Override
		public double getVelocity() {
			return getGyroVelocity();
		}

	}

	public void initializeGyroMP() {
		GyroMPIn gyroMPIn = new GyroMPIn();
		GyroMPOut gyroMPOut = new GyroMPOut();
		m_gyroMotionProfilingController = new MotionProfilingController(m_gyroMPPositionkp, m_gyroMPPositionki,
				m_gyroMPPositionkd, m_gyroMPVelocitykp, m_gyroMPVelocityki, m_gyroMPVelocitykd, m_gyroMPVelocitykf,
				kGyroMaxVelocity, kGyroMaxAcceleration, kGyroMaxJerk, gyroMPIn, gyroMPOut);
		m_gyroMotionProfilingController.setAbsoluteTolerance(kEncoderMPTolerance);

	}

	public void enableGyroMP(double setpoint) {
		m_gyroMotionProfilingController.setSetpoint(setpoint);
		m_gyroMotionProfilingController.enable();
	}

	public boolean isDoneGyroMP() {
		return m_gyroMotionProfilingController.onTarget();
	}

	public void disableGyroMP() {
		m_gyroMotionProfilingController.disable();
	}

	public double getGyroVelocity() {
		double currentTime = Timer.getFPGATimestamp();
		double currentAngle = getGyroPosition();
		if (Double.isNaN(m_gyroPreviousPosition) || Math.abs(currentTime - m_gyroPreviousTime) > 0.5) {
			m_gyroPreviousPosition = currentAngle;
			m_gyroPreviousTime = currentTime;
			return 0.0;
		}
		double changeInPosition = currentAngle - m_gyroPreviousPosition;
		double changeInTime = Math.abs(currentTime - m_gyroPreviousTime);
		double velocity = changeInPosition / changeInTime;

		return velocity;
	}

	public double getGyroPosition() {

		return RobotMap.navX.getRobotAngle();
	}

	private class UltrasonicMPOut implements PIDOutput {

		@Override
		public void pidWrite(double output) {
			gyroCorrectMove(output, 0.0, 1.0, false);
		}

	}

	private class UltrasonicMPIn implements MPSource {

		@Override
		public double getPosition() {
			return (m_ultrasonicMPSetpoint - getDistanceFromFront()) * DriveTrain.ENCODER_TICKS_PER_INCH;
		}

		@Override
		public double getVelocity() {
			return getTalonVelocity();
		}

	}

	public void initializeUltrasonicMP() {
		UltrasonicMPIn ultrasonicMPIn = new UltrasonicMPIn();
		UltrasonicMPOut ultrasonicMPOut = new UltrasonicMPOut();
		m_ultrasonicMotionProfilingController = new MotionProfilingController(m_ultrasonicMPPositionkp,
				m_ultrasonicMPPositionki, m_ultrasonicMPPositionkd, m_encoderMPVelocitykp, m_encoderMPVelocityki,
				m_encoderMPVelocitykd, m_encoderMPVelocitykf, kEncoderMaxVelocity, kEncoderMaxAcceleration,
				kEncoderMaxJerk, ultrasonicMPIn, ultrasonicMPOut);
		m_ultrasonicMotionProfilingController.setAbsoluteTolerance(kUltrasonicMPTolerance);

	}

	public void enableUltrasonicMP(double setpoint) {
		double currentUltrasonicPosition = getDistanceFromFront();
		double distanceToTravel = currentUltrasonicPosition - setpoint;
		m_ultrasonicMPSetpoint = setpoint;
		m_ultrasonicMotionProfilingController.setSetpoint(distanceToTravel * DriveTrain.ENCODER_TICKS_PER_INCH);
		m_ultrasonicMotionProfilingController.enable();
	}

	public boolean isDoneUltrasonicMP() {

		return m_ultrasonicMotionProfilingController.onTarget();
	}

	public void disableUltrasonicMP() {
		m_ultrasonicMotionProfilingController.disable();
	}

}
